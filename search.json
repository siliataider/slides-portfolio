[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "ROOT Open Projects",
    "section": "",
    "text": "RNTuple & I/O\n\n\n\n\nS3 Backend for RNTuple\n\n\nC++ HTTP\n\n\nResponsible: Jakob Blomer\n\n\nTarget:Master Thesis / Tech / ATLAS Quali Task (perhaps related to ATLAS cloud R&D)\n\n\n6-12 months\n\n\nRNTuple, I/O\n\n\nThe RNTuple I/O provides the data format and basic storage stack for HL-LHC data. It has been designed to allow for exchangeable storage backends, including file system access, XRootD access, and object stores. Proof-of-concept implementations for DAOS and S3 object stores exist but have not been further pursued. The goal of this project is to develop a robust (pre-release quality) implementation for storing RNTuple data in S3, the standard cloud storage protocol. In particular, the project needs to design and implement a URL scheme to address RNTuple objects and an efficient HTTP base layer to access objects and byte ranges. The project should include benchmarks comparing S3 to XRootD and remote file system access in the same data center (e.g., using the AGC benchmark), and a benchmark measuring the effect of network latency to end-to-end performance\n\n\n\n\nGraceful crash recovery of RNTuple write streams\n\n\nC++\n\n\nResponsible: Jakob Blomer\n\n\nTarget: Master Thesis / Tech\n\n\n12 months\n\n\nRNTuple, I/O\n\n\nThe RNTuple I/O provides the data format and basic storage stack for HL-LHC data. Its current use include analysis and reconstruction workflows, with some early prototyping of data acquisition use cases. For data acquisition in particular, where failing jobs cannot simply be restarted, the capability to recover written data after an unexpected termination of the writer process is critical. The RNTuple design allows for that feature provided that a snapshot of the meta-data (the on-disk location of pages) is regularly flushed to disk (not only at the end). The project should design and implement a mechanism to automatically flush a consistent state of the meta-data during writing at a location that can be located after a crash (e.g., a well-known byte offset such as every 100MB). An extensive test suite should be developed alongside the feature.\n\n\n\n\nAbstract Object Access in ROOT Schema Evolution\n\n\nC++\n\n\nResponsible: Jakob Blomer\n\n\nTarget: Grad\n\n\n18-24 months\n\n\nRNTuple, I/O\n\n\nThe ROOT schema evolution system enables users to define I/O customization rules that map on-disk types to their evolved versions in-memory. A limitation of the current approach is the fact that the on-disk information (e.g., class members) need to be accessed in the form of existing C++ types. Effectively, that may require users of complex event data models to preserve the history of the class layouts. This project aims at developing an extension to the ROOT schema evolution that allows access to on-disk classes in an abstract way, as a combination of PoDs, abstract records and abstract collections. As a result, certain schema evolution cases related to the change of class shapes (e.g., moving data members in the class hierarchy) should be greatly simplified.\n\n\n\n\n\n\n\n\n\nContact Us\n\n\n\nContribute a Project Idea!\n\n\nIf you have an idea for a ROOT project, submit it here!\n\n\nName \nEmail \nProject Idea\n\n\nSubmit"
  },
  {
    "objectID": "slides.html#about-this-portfolio",
    "href": "slides.html#about-this-portfolio",
    "title": "ROOT Open Projects",
    "section": "About this Portfolio",
    "text": "About this Portfolio\n\nA collection of concrete and well-scoped open projects to attract contributions beyond the ROOT Core Team.\n\nSuitable for a variety of contributors: students, researchers, and developers."
  }
]